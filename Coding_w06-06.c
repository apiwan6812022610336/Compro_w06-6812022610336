#include <stdio.h>

int main() {
    
    int a = 5;    
    int b = 2;    
    float x = 3.0f; 
    float y = 4.5f; 

    int r1;
    int r2;
    float r3;
    float r4;

    printf("Initial values: a = %d, b = %d, x = %.1f, y = %.1f\n\n", a, b, x, y);

    // นิพจน์ที่ 1: int r1 = a++ * b + (int)y % 3;
    // การวิเคราะห์ (Order of Evaluation):
    // 1. `a++`: Postfix increment. ค่า `a` (5) จะถูกใช้ในการคำนวณก่อน จากนั้น `a` จะเพิ่มขึ้นเป็น 6
    // 2. `(int)y`: Type casting. ค่า `y` (4.5) จะถูกแปลงเป็นจำนวนเต็ม คือ 4
    // 3. `a++ * b`: (5 * 2) = 10 (การคูณมีลำดับความสำคัญสูงกว่า)
    // 4. `(int)y % 3`: (4 % 3) = 1 (Modulo มีลำดับความสำคัญสูงกว่า)
    // 5. `10 + 1`: 11 (การบวก)
    r1 = a++ * b + (int)y % 3;
    printf("1. int r1 = a++ * b + (int)y %% 3;\n"); // ใช้ %% เพื่อพิมพ์เครื่องหมาย %
    printf("   r1 = %d (a after: %d)\n", r1, a); // ผลลัพธ์: r1 = 11, a = 6

    // นิพจน์ที่ 2: int r2 = (a > b) && ((int)x / b < 2);
    // การวิเคราะห์ (Order of Evaluation):
    // 1. `(a > b)`: (6 > 2) เป็นจริง (True) (ใช้ค่า 'a' ที่ถูกเปลี่ยนจากนิพจน์ก่อนหน้า)
    // 2. `(int)x`: Type casting. ค่า `x` (3.0) จะถูกแปลงเป็นจำนวนเต็ม คือ 3
    // 3. `(int)x / b`: (3 / 2) = 1 (การหารจำนวนเต็ม เพราะ operands เป็น int ทั้งคู่)
    // 4. `(1 < 2)`: เป็นจริง (True)
    // 5. `True && True`: เป็นจริง (True) ซึ่งใน C จะเป็น 1 สำหรับค่า True
    r2 = (a > b) && ((int)x / b < 2);
    printf("2. int r2 = (a > b) && ((int)x / b < 2);\n");
    printf("   r2 = %d\n", r2); // ผลลัพธ์: r2 = 1

    // นิพจน์ที่ 3: float r3 = ++x * y - a / 2;
    // การวิเคราะห์ (Order of Evaluation):
    // 1. `++x`: Prefix increment. ค่า `x` (ปัจจุบัน 3.0) จะถูกเพิ่มขึ้นเป็น 4.0 ก่อนถูกใช้ในการคำนวณ
    // 2. `a / 2`: (6 / 2) = 3 (การหารจำนวนเต็ม เพราะ `a` เป็น int)
    // 3. `4.0 * 4.5`: 18.0 (การคูณ)
    // 4. `18.0 - 3`: 15.0 (การลบระหว่าง float กับ int, int จะถูกแปลงเป็น float ก่อน)
    r3 = ++x * y - a / 2;
    printf("3. float r3 = ++x * y - a / 2;\n");
    printf("   r3 = %.2f (x after: %.2f)\n", r3, x); // ผลลัพธ์: r3 = 15.00, x = 4.00

    // นิพจน์ที่ 4: float r4 = (((x += 1.5) > y) || (b --> 0));
    // การวิเคราะห์ (Order of Evaluation):
    // 1. `(x += 1.5f)`: `x = x + 1.5f`. ค่า `x` (ปัจจุบัน 4.0 จากนิพจน์ที่ 3) จะกลายเป็น 5.5
    // 2. `(x > y)`: (5.5 > 4.5) เป็นจริง (True)
    // 3. `(b-- > 0)`: `b--` เป็น postfix decrement. ค่า `b` เดิม (2) จะถูกใช้ในการเปรียบเทียบก่อน (2 > 0) เป็นจริง (True) จากนั้น `b` จะลดลงเป็น 1
    // 4. `True || True`: เป็นจริง (True) ซึ่งใน C จะเป็น 1.0f สำหรับค่า True (เนื่องจาก r4 เป็น float)
    r4 = (((x += 1.5f) > y) || (b-- > 0)); // ใช้ 1.5f เพื่อให้เป็น float literal
    printf("4. float r4 = (((x += 1.5) > y) || (b --> 0));\n");
    printf("   r4 = %.2f (x after: %.2f, b after: %d)\n", r4, x, b); // ผลลัพธ์: r4 = 1.00, x = 5.50, b = 1

    return 0; // สิ้นสุดโปรแกรม
}